<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<jsp:root 
	xmlns:c="http://java.sun.com/jsp/jstl/core" 
	xmlns:fn="http://java.sun.com/jsp/jstl/functions" 
	xmlns:fmt="http://java.sun.com/jsp/jstl/fmt"
	xmlns:jsp="http://java.sun.com/JSP/Page" 
	xmlns:spring="http://www.springframework.org/tags" 
	xmlns:fx="http://igd.fraunhofer.de/tags/elfunctions" 
	version="2.0"
	>
	<jsp:output omit-xml-declaration="yes" />
	
	<jsp:directive.attribute name="projection" type="java.lang.String" required="false" rtexprvalue="true"/>
	<jsp:directive.attribute name="tmsUrl" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="tmsLayers" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="maxExtent" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="restrictedExtent" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="resolutions" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="serverResolutions" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="vorgaenge" type="java.util.List" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="oviMargin" type="java.lang.String" required="false" rtexprvalue="true"/>
	<jsp:directive.attribute name="cssStyle" type="java.lang.String" required="false" rtexprvalue="true"/>
	<jsp:directive.attribute name="delegiert" type="java.lang.Boolean" required="false" rtexprvalue="true"/>
	<jsp:directive.attribute name="wmsUrl" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="wmsTitle" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="wmsLayers" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="wmsFormat" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="wmsTransparent" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="wmsMinScale" type="java.lang.String" required="true" rtexprvalue="true"/>
	<jsp:directive.attribute name="wmsSingleTile" type="java.lang.String" required="true" rtexprvalue="true"/>

	<c:if test="${empty projection}">
		<c:set var="projection" value="EPSG:25833"/>
	</c:if>
	<c:if test="${empty oviMargin}">
		<c:set var="oviMargin" value="400"/>
	</c:if>
	<c:if test="${empty delegiert}">
		<c:set var="delegiert" value="false"/>
	</c:if>
	
	<!--<c:set value="${vorgaenge[0].oviWkt}" var="ovi"/>-->

    <div id="map" class="smallmap" style="${cssStyle}"><!-- //OpenLayers --></div>

	<c:url value="/script/openLayers/theme/default/style.css" var="url"/>
    <link rel="stylesheet" href="${url}" type="text/css"><!-- //OpenLayers Style --></link>
	<c:url value="/script/openLayers/OpenLayers.js" var="url"/>
	<script src="${url}" type="text/javascript"><!-- //OpenLayers --></script>
	<c:url value="/script/openLayers/theme/dark/" var="url"/>
    
    <script type="text/javascript">
	        var map, vlayer;
	        var formater;
            
            var bounds = new OpenLayers.Bounds(${maxExtent});
	        function openVorgang(feature) {
	        	<c:choose>
	        		<c:when test="${delegiert}">
	        			<c:url value="/vorgang/delegiert/" var="vorgangurl"/>
	        		</c:when>
	        		<c:otherwise>
	        			<c:url value="/vorgang/" var="vorgangurl"/>
	        		</c:otherwise>
	        	</c:choose>
	        	url = '${vorgangurl}'+feature.attributes['vorgangid']+'/uebersicht';
	            location.href=url;
	        }
            
            function onFeatureSelect(feature) {
	        	//falls Cluster
                if(feature.cluster) {
                    //abbrechen und Feature abwählen
                    control_select.unselectAll();
                    return;
                }
                else openVorgang(feature);
	        }
	        
	        function initOpenLayers(){
	        	//Theme definieren
	        	OpenLayers.ImgPath = "${url}";
	        	
	            //Formater definieren
	    		var formatOptions = {
	    			'internalProjection': new OpenLayers.Projection('${projection}'),
	    			'externalProjection': new OpenLayers.Projection('${projection}')
				};
				formater = new OpenLayers.Format.WKT(formatOptions);

				//Regeln für das Clustering definieren
                <c:url value="/images/generalisiert.png" var="png_generalisiert"/>
                clusterRules = [
			        //Regel für Clusteranzeige
			        new OpenLayers.Rule({
			        	filter: new OpenLayers.Filter.Comparison({
			        		type: OpenLayers.Filter.Comparison.GREATER_THAN,
			        		property: "count",
			        		value: 1
			        	}),
			        	symbolizer: {    		
			    			label: '<![CDATA[$]]>{count}',
			        		graphicWidth: 30,
			    			graphicHeight: 30,
                            graphicXOffset: -15,
			    			graphicYOffset: -15,
                            externalGraphic: "${png_generalisiert}",
                            fontWeight: "bold",
                            labelAlign: "cm",
                            cursor: "default"
			        	}
			        }),
			        //Regel für Standardanzeige
			        new OpenLayers.Rule({
			        	elseFilter: true,
			        	symbolizer: {}
			        })
			    ];
                
                //Clustering konfigurieren
                //<![CDATA[
                clusterStrategy = new OpenLayers.Strategy.Cluster({
                    distance: 42,
                    threshold: 2,
                    deactivate: function() {
                        var deactivated = OpenLayers.Strategy.prototype.deactivate.call(this);
                        if (deactivated) {
                            var features = [];
                            var clusters = this.layer.features;
                            for (var i=0; i<clusters.length; i++) {
                                var cluster = clusters[i];
                                if (cluster.cluster) {
                                    for (var j=0; j<cluster.cluster.length; j++) {
                                        features.push(cluster.cluster[j]);
                                    }
                                }
                                else {
                                    features.push(cluster);
                                }
                            }
                            this.layer.removeAllFeatures();
                            this.layer.events.un( { "beforefeaturesadded" : this.cacheFeatures, "moveend" : this.cluster, scope : this } );
                            this.layer.addFeatures(features);
                        }
                        return deactivated;
                    },
                    activate: function() {
                        var activated = OpenLayers.Strategy.prototype.activate.call(this);
                        if (activated) {
                            var features = [];
                            var clusters = this.layer.features;
                            for (var i=0; i<clusters.length; i++) {
                                var cluster = clusters[i];
                                if (cluster.cluster) {
                                    for (var j=0; j<cluster.cluster.length; j++) {
                                        features.push(cluster.cluster[j]);
                                    }
                                }
                                else {
                                    features.push(cluster);
                                }
                            }
                            this.layer.removeAllFeatures();
                            this.layer.events.on( { "beforefeaturesadded" : this.cacheFeatures, "moveend" : this.cluster, scope : this});
                            this.layer.addFeatures(features);
                        }
                        return activated;
                    }
                });
                //]]>
                
                //Layer für OVI konfigurieren
                vlayerstyle = new OpenLayers.Style({pointRadius: 15, graphicWidth: 24, graphicHeight: 29, graphicXOffset: -3, graphicYOffset: -27, cursor: "pointer", externalGraphic:'<![CDATA[$]]>{type}'}, {rules: clusterRules});
                vlayerstylemap = new OpenLayers.StyleMap({"default": vlayerstyle});
                vlayer = new OpenLayers.Layer.Vector( "gesuchte Vorgänge", { strategies: [clusterStrategy], styleMap: vlayerstylemap } );
                
                //Hilfslayer für die Zwischenablage der OVI konfigurieren
                hilfe = new OpenLayers.Layer.Vector( "Hilfslayer", { styleMap: vlayerstylemap } );
	        	
				//Layer für OVI initialisieren, aber OVI vorerst im Hilfslayer ablegen
                <c:forEach items="${vorgaenge}" var="vorgang" varStatus="s">
                    initFeature_${s.index} = formater.read('${vorgang.oviWkt}');
                    if (initFeature_${s.index}) {
                        <c:url value="/images/${vorgang.typ}_${vorgang.status}_45.png" var="type"/>
                        initFeature_${s.index}.attributes = {type:'${type}', vorgangid:${vorgang.id}};
                        if(initFeature_${s.index}.constructor != Array) initFeature_${s.index} = [initFeature_${s.index}];
                        hilfe.addFeatures(initFeature_${s.index});
                    }
                </c:forEach>
                initBounds = hilfe.getDataExtent();
                if(initBounds) {
                    initBounds.left = initBounds.left - ${oviMargin};
                    initBounds.right = initBounds.right + ${oviMargin};
                    initBounds.top = initBounds.top + ${oviMargin};
                    initBounds.bottom = initBounds.bottom - ${oviMargin};
                }

	        	//Controls
	        	//Zoomen auf den ausgewählten Bereich
	        	control_zoomBox = new OpenLayers.Control.ZoomBox({title:'auf Kartenausschnitt zoomen'});
	        	//Ansicht vor und zurück
	        	control_navigationHistory = new OpenLayers.Control.NavigationHistory();
	        	control_navigationHistory.previous.title='Ansicht zurück';
	        	control_navigationHistory.next.title='Ansicht vor';
	        	//Toolbar
	        	editingToolbar = new OpenLayers.Control.EditingToolbar(vlayer);
	        	//Control: Karte verschieben
	        	control_navigation = editingToolbar.controls[0];
	        	//Control: OVI einzeichnen
	        	control_drawFeaturePoint = editingToolbar.controls[1];
	        	//Control: maximal herauszoomen
	        	control_zoomToMaxExtent = new OpenLayers.Control.ZoomToMaxExtent({title:'ganze Kartenausdehnung anzeigen'});
	        	//Control: Zoom in
	        	control_zoomIn = new OpenLayers.Control.ZoomIn({title:'in Karte hineinzoomen'});
	        	//Control: Zoom out
	        	control_zoomOut = new OpenLayers.Control.ZoomOut({title:'aus Karte herauszoomen'});

	        	control_select = new OpenLayers.Control.SelectFeature(vlayer, {clickout: true, onSelect: onFeatureSelect});
	        	
	        	map = new OpenLayers.Map( 'map', { 
	        		controls: [
	   		    		new OpenLayers.Control.LayerSwitcher({roundedCorner:false}),
	   		    		new OpenLayers.Control.PanZoomBar(), 
	   		    		new OpenLayers.Control.Navigation(), 
	   		    		new OpenLayers.Control.MousePosition({numDigits: 0, suffix: ' m Nord ETRS89/UTM-33N', separator: ' m Ost, '}),
	   		    		editingToolbar,
	   		    		control_zoomToMaxExtent
	   		    	],
	   		    	projection: '${projection}',
	   		    	resolutions: [${resolutions}],
	   		    	units: 'm',
					restrictedExtent: new OpenLayers.Bounds(${restrictedExtent}),
					maxExtent: bounds
	        	} );
				
                <c:forEach items="${fx:array(tmsLayers)}" var="layer">
                    <c:set value="${fx:array2(layer,':')}" var="layerOption"/>
                        layer = new OpenLayers.Layer.TMS( 
                            "${layerOption[0]}", 
                            "${tmsUrl}", {
                                layername: '${layerOption[1]}',
                                type: 'png',
                                transitionEffect: 'resize',
                                serverResolutions: [${serverResolutions}],
                                tileSize: new OpenLayers.Size(256, 256)
                            } );
                        map.addLayer(layer);
                </c:forEach>
                
                var luftbild = new OpenLayers.Layer.TMS( 
                    "Luftbild", 
                    "http://geo.sv.rostock.de/geodienste/luftbild/tms/", {
                        layername: 'luftbild_EPSG25833',
                        type: 'png',
                        transitionEffect: 'resize',
                        serverResolutions: [529.166666667, 352.777777778, 264.583333333, 176.388888889, 88.1944444444, 52.9166666667, 35.2777777778, 28.2222222222, 22.9305555556, 17.6388888889, 12.3472222222, 8.8194444444, 7.0555555556, 5.2916666667, 3.5277777778, 2.6458333333, 1.7638888889, 0.8819444444, 0.3527777778, 0.1763888889],
                        tileSize: new OpenLayers.Size(256, 256)
                    } );
                map.addLayer(luftbild);
                
                var poiLayer = new OpenLayers.Layer.WMS( 
                    "${wmsTitle}", 
                    "${wmsUrl}", {
                        layers: "${wmsLayers}",
                        format: "${wmsFormat}",
                        transparent: "${wmsTransparent}",
                        minScale: "${wmsMinScale}",
                        singleTile: "${wmsSingleTile}"
                    } );
                map.addLayer(poiLayer);
                
                //höchste Zoomstufe ermitteln (auf dieser soll kein Clustering mehr stattfinden)
                var clusterMaxZoom = map.getNumZoomLevels() - 1;
                
                //Hilfsvariable festlegen zur Vermeidung des ständigen Neuladens der Meldungen
                var haveToReload = 0;
                
                //<![CDATA[
                map.events.register("move", null, function() {
                    //aktuelle Zoomstufe ermitteln
                    var zoom = map.getZoom();
                    //Clustering deaktivieren, falls höchste Zoomstufe erreicht
                    if (zoom >= clusterMaxZoom && haveToReload == 0) {
                        clusterStrategy.deactivate();
                        haveToReload = 1;
                    }
                    else if (zoom < clusterMaxZoom && haveToReload == 1) {
                        clusterStrategy.activate();
                        haveToReload = 0;
                    }
                });
                //]]>

	            map.addLayer(vlayer);
                
                //OVI aus dem Hilfslayer in den regulären Layer laden
                vlayer.addFeatures(hilfe.features);

	            map.addControl(control_navigationHistory);
	            map.addControl(control_select);
	            
	            editingToolbar.addControls([control_navigationHistory.previous, control_navigationHistory.next, control_zoomBox, control_zoomToMaxExtent, control_zoomOut, control_zoomIn]);

				editingToolbar.controls = [control_navigationHistory.next, control_navigationHistory.previous, control_zoomToMaxExtent, control_zoomBox, control_zoomOut, control_zoomIn, control_navigation];

	            editingToolbar.redraw();
	        	editingToolbar.activateControl(control_navigation);
	            control_select.activate();

				//initial Zoomen
				map.zoomToExtent(initBounds);
				
				$('div.olControlNavigationItemActive').attr("title", "Karte verschieben");
				$('div.olControlNavigationItemInactive').attr("title", "Karte verschieben");
				$('div.olControlDrawFeaturePointItemActive').attr("title", "Position setzen");
				$('div.olControlDrawFeaturePointItemInactive').attr("title", "Position setzen");
				$('img#OpenLayers_Control_MaximizeDiv_innerImage').attr("title", "Karteninhalte ändern");
				$('img#OpenLayers_Control_MaximizeDiv_innerImage').attr("style", "cursor:pointer");
	        }
	
			initOpenLayers();
		</script>
</jsp:root>
